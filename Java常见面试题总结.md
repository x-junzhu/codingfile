## JavaEE基础
### 1.谈谈对封装性的理解
① 为什么引入封装性?<br>
首先,我的程序设计追求"高内聚,低耦合"
+ 高内聚:类的内部数据操作细节自己完成，不允许外部干涉;
+ 低耦合:仅对外暴露少量的方法用于使用.


其次,隐藏对象内部的复杂性,只对外公开简单的接口.便于外界调用,从而提高系统的可扩展性、可维护性.通俗的说,把该隐藏的隐藏起来,该暴露的暴露出来.这就是封装性的设计思想.

② 问题引入

当我们创建一个类的对象以后，我们可以通过"对象.属性"的方式，对对象的属性进行赋值。这里，赋值操作要受到属性的数据类型和存储范围的制约。除此之外，没其他制约条件。但是，在实际问题中，我们往往需要给属性赋值加入额外的限制条件。这个条件就不能在属性声明时体现，我们只能通过方法进行限制条件的添加。（比如：setLegs()同时，我们需要避免用户再使用"对象.属性"的方式对属性进行赋值。则需要将属性声明为私有的(private).
  -->此时，针对于属性就体现了封装性。


③ 封装性的具体体现?
```
体现一: 将类的属性私有化，同时提供公共的方法来获取和设置此属性的值
体现二: 不对外暴露的私有方法
体现三: 单例模式(将构造器私有化)
体现四:如果不希望类在包外被调用，可以将类设置为确省
```
### 2.谈一谈重写和重载
① 概念

重载:同一个类中,相同的方法名;不同的参数列表,包括不同的参数类型和不同的参数个数

重写:子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作.
重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。

② 重载和重写的规则

③ 重载: 不表现为多态性<br>
重写: 表现为多态性

重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。
所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；
而对于多态，只等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。 

### 3 谈一谈对多态性的理解
```
① 实现代码的通用性。
② Object类中定义的public boolean equals(Object obj){  }
  JDBC:使用java程序操作(获取数据库连接、CRUD)数据库(MySQL、Oracle、DB2、SQL Server)
③ 抽象类、接口的使用肯定体现了多态性。（抽象类、接口不能实例化）
```

### 4 final、finally、finalize的区别？
final 是Java语言中的一个关键字


finally 是try catch finally中的一部分


finalize 是java.lang.Object类中的一个方法,用来销毁内存中没有指针指向的对象,一般不显示调用,而是有Java的垃圾回收器自行调用.

### 5 包装类
包装类是将基本数据类型升级为对应的类, 将相关的基本数据类型封装成对应包装类的一个属性.
比如:int -> Integer, 在Integer内部就定义了一个int value;的属性.

### 6 谈一谈对 == 和 equals()方法理解?
equals(): 方法
1. 是一个方法，而非运算符
2. 只能适用于引用数据类型
3. Object类中equals()的定义：
    public boolean equals(Object obj) {
	        return (this == obj);
	  }
+ 说明：Object类中定义的equals()和==的作用是相同的：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体

4. 像String、Date、File、包装类等都重写了Object类中的equals()方法。重写以后，比较的不是
+ 两个引用的地址是否相同，而是比较两个对象的"实体内容"是否相同。  
5. 通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的"实体内容"是否相同。那么，我们就需要对Object类中的equals()进行重写.重写的原则：比较两个对象的实体内容是否相同.

== ：运算符
1. 可以使用在基本数据类型变量和引用数据类型变量中
2. 如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（不一定类型要相同）
+ 如果比较的是引用数据类型变量：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体
+ 补充： == 符号使用时，必须保证符号左右两边的变量类型一致。

### 7 常见的异常有哪些？请举例说明
```
java.lang.Throwable
  |-----java.lang.Error:一般不编写针对性的代码进行处理。
  |-----java.lang.Exception:可以进行异常的处理
      |------编译时异常(checked)
        |-----IOException
        |-----FileNotFoundException
        |-----ClassNotFoundException
      |------运行时异常(unchecked,RuntimeException)
        |-----NullPointerException
        |-----ArrayIndexOutOfBoundsException
        |-----ClassCastException
        |-----NumberFormatException
        |-----InputMismatchException
        |-----ArithmeticException
```
### 8 synchronized 和 lock有什么区别？
+ Java是如何解决线程安全问题的，有三种方式:同步代码块、同步方法、同步锁
+ 相同：二者都可以解决线程安全问题
+ 不同：synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器,Lock需要手动的启动同步lock()，同时结束同步也需要手动的实现unlock()

### 9 sleep() 和 wait() 方法的区别？
```
相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。
不同点：
① 两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait()
② 调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中
③ 关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。
```
### 10 Java中多线程的创建有几种方式？
```
方式一：继承Thread类的方式
方式二：实现Runnable接口的方式
新增方式一：实现Callable接口。 --- JDK 5.0新增
新增方式二：使用线程池
如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？
1. call()可以返回值的。
2. call()可以抛出异常，被外面的操作捕获，获取异常的信息
3. Callable是支持泛型的
好处：
1.提高响应速度（减少了创建新线程的时间）
2.降低资源消耗（重复利用线程池中线程，不需要每次都创建）
3.便于线程管理
      corePoolSize：核心池的大小
      maximumPoolSize：最大线程数
      keepAliveTime：线程没任务时最多保持多长时间后会终止
```
### 11 String、StringBuffer、StringBuilder的区别?
```
String:不可变字符序列，底层使用char[]存储。
StringBuffer:可变的字符序列;线程安全，效率低;底层使用char[]存储。
StringBuilder:可变的字符序列;JDK5.0新增，线程不安全，效率高;底层使用char[]存储。
扩容问题:如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。
默认情况下，扩容为原来容量的2倍 + 2，同时将原数组中的元素复制到新的数组中。
```
### 12 ArrayList、LinkedList、Vector三者的异同点？

同: 三者都是实现了List接口，存储数据的特点的相同：存储有序的、可重复的数据<br>
不同:<br>
 ArrayList:是List的主要实现类，线程不安全、效率高；底层使用Object[] elementData存储.<br>
 源码分析(jdk1.8):ArrayList list = new ArrayList()初始化时(没有添加元素之前)底层是只是新建一个空的Object[]对象数组,当开始add数据的时候,则见一个长度为10的默认Object[]对象数组,用来保存数据,当添加到超过数据长度是,开始扩容, 默认情况是扩容为当前数组长度的1.5倍,同时将原来数组中的数据复制到当前数组.
 而(jdk1.7)在初始化时候就建立默认长度的Object[]对象数组,其他的过程和jdk1.8一样.<br>
 LinkedList: 对于频繁的插入和删除操作，使用此类效率比ArrayList高；底层使用双向列表存储.<br>
 源码分析(jdk1.8):LinkedList list = new LinkedList()初始化时,在内部声明了一个内部类Node节点,维护的是一个双链表结构,每一次add操作都是将该对象封装到Node节点中.<br>
 Vecetor:作为List接口的古老实现类；线程安全、效率低；底层使用Object[] elementData存储.<br>
 源码分析:jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组在扩容方面，默认扩容为原来的数组长度的2倍。
### 13 HashMap的底层实现原理？
```
从JDK 1.7开始说起:
HashMap map = new HashMap()开始在底层创建一个长度为16的Entry[] 数组.在此之前已经
put(key, value)多次,知道本次map.put(key1, value1),首先通过可以所在类的hashCode()计算器哈希值，
即该条数据在Entry[]数组中位置：
  如果该哈希值对应Entry[]数组的位置为空，则插入成功 --> 情况1
  如果该哈希值对应Entry[]数组的位置不为空(可能存在一条数据或者一个链表),开始对比
  (key1, value1)的哈希值与该位置上所有元素的哈希值:
      如果(key1, value1)与该位置上所有元素的哈希值均不相同，则插入成功 --> 情况2
      如果(key1, value1)与该位置上的某条数据(key2, value2)的哈希值相等，则开始比较key1.value.equals(key2.value):
          如果equals返回false，则添加成功 --> 情况3
          如果equals返回true,则用value2替换value1
说明: 情况2和情况3(key1, value1)都是采用链表方式存储.
补充JDK 1.8:
1.new HashMap()的时候不会一开始就创建一个长度为16的数组，只有在第一次put()操作后，才创建数组。
2.JDK 1.8底层使用的数组是Node[],而非Entry[]
3.JDK 1.7底层使用的是数组+链表, JDK 1.8使用的是数组+链表+红黑树
4.JDK 1.7的链表采用的是头插法，JDK 1.8的链表采用的是尾插法。
5.JDK 1.8中当链表长度大于8，并且Node[]数组长度大于64时，链表转换成红黑树。
在不断添加的过程中会涉及到扩容问题，当数组中位置使用超过临界值且下一个存储的位置不空的时候，将数组长度扩容为原来的两倍，并且把原数组复制到新的数组中。
HashMap底层典型属性的属性的说明：
DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16
DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75
threshold：扩容的临界值，=容量*填充因子：16 * 0.75 => 12
TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树:8
MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量:64
```
### 14 HashMap和 Hashtable的异同点？

### 15 CurrentHashMap 与 Hashtable的异同？
