## JavaEE基础
### 1.谈谈对封装性的理解
① 为什么引入封装性?<br>
首先,我的程序设计追求"高内聚,低耦合"
+ 高内聚:类的内部数据操作细节自己完成，不允许外部干涉;
+ 低耦合:仅对外暴露少量的方法用于使用.


其次,隐藏对象内部的复杂性,只对外公开简单的接口.便于外界调用,从而提高系统的可扩展性、可维护性.通俗的说,把该隐藏的隐藏起来,该暴露的暴露出来.这就是封装性的设计思想.

② 问题引入

当我们创建一个类的对象以后，我们可以通过"对象.属性"的方式，对对象的属性进行赋值。这里，赋值操作要受到属性的数据类型和存储范围的制约。除此之外，没其他制约条件。但是，在实际问题中，我们往往需要给属性赋值加入额外的限制条件。这个条件就不能在属性声明时体现，我们只能通过方法进行限制条件的添加。（比如：setLegs()同时，我们需要避免用户再使用"对象.属性"的方式对属性进行赋值。则需要将属性声明为私有的(private).
  -->此时，针对于属性就体现了封装性。


③ 封装性的具体体现?
```
体现一: 将类的属性私有化，同时提供公共的方法来获取和设置此属性的值
体现二: 不对外暴露的私有方法
体现三: 单例模式(将构造器私有化)
体现四:如果不希望类在包外被调用，可以将类设置为确省
```
### 2.谈一谈重写和重载
① 概念

重载:同一个类中,相同的方法名;不同的参数列表,包括不同的参数类型和不同的参数个数

重写:子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作.
重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。

② 重载和重写的规则

③ 重载: 不表现为多态性<br>
重写: 表现为多态性

重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。
所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；
而对于多态，只等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。 

### 3 谈一谈对多态性的理解
```
① 实现代码的通用性。
② Object类中定义的public boolean equals(Object obj){  }
  JDBC:使用java程序操作(获取数据库连接、CRUD)数据库(MySQL、Oracle、DB2、SQL Server)
③ 抽象类、接口的使用肯定体现了多态性。（抽象类、接口不能实例化）
```

### 4 final、finally、finalize的区别？
final 是Java语言中的一个关键字


finally 是try catch finally中的一部分


finalize 是java.lang.Object类中的一个方法,用来销毁内存中没有指针指向的对象,一般不显示调用,而是有Java的垃圾回收器自行调用.

### 5 包装类
包装类是将基本数据类型升级为对应的类, 将相关的基本数据类型封装成对应包装类的一个属性.
比如:int -> Integer, 在Integer内部就定义了一个int value;的属性.

### 6 谈一谈对 == 和 equals()方法理解?
equals(): 方法
1. 是一个方法，而非运算符
2. 只能适用于引用数据类型
3. Object类中equals()的定义：
    public boolean equals(Object obj) {
	        return (this == obj);
	  }
+ 说明：Object类中定义的equals()和==的作用是相同的：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体

4. 像String、Date、File、包装类等都重写了Object类中的equals()方法。重写以后，比较的不是
两个引用的地址是否相同，而是比较两个对象的"实体内容"是否相同。  
5. 通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的"实体内容"是否相同。那么，我们就需要对Object类中的equals()进行重写.重写的原则：比较两个对象的实体内容是否相同.

== ：运算符
1. 可以使用在基本数据类型变量和引用数据类型变量中
2. 如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（不一定类型要相同）
+ 如果比较的是引用数据类型变量：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体
+ 补充： == 符号使用时，必须保证符号左右两边的变量类型一致。
> 可以在右边加东西唉

### 7 常见的异常有哪些？请举例说明
```
java.lang.Throwable
  |-----java.lang.Error:一般不编写针对性的代码进行处理。
  |-----java.lang.Exception:可以进行异常的处理
      |------编译时异常(checked)
        |-----IOException
        |-----FileNotFoundException
        |-----ClassNotFoundException
      |------运行时异常(unchecked,RuntimeException)
        |-----NullPointerException
        |-----ArrayIndexOutOfBoundsException
        |-----ClassCastException
        |-----NumberFormatException
        |-----InputMismatchException
        |-----ArithmeticException
```
### 8 Java是如何解决线程安全问题的,有几种方式？并对比几种方式的不同.
```
Java是如何解决线程安全问题的，有三种方式:同步代码块、同步方法、同步锁
方式一:同步代码块
synchronized(同步监视器){
    //需要被同步的代码
}
说明:1.操作共享数据的代码，即为需要被同步的代码。  --> 不能包含代码多了，也不能包含代码少了。
     2.共享数据：多个线程共同操作的变量。比如：ticket就是共享数据。
     3.同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。
        要求：多个线程必须要共用同一把锁。

补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。
在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视器。

方式二：同步方法
如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。

关于同步方法的总结：
  1. 同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。
  2. 非静态的同步方法，同步监视器是：this
     静态的同步方法，同步监视器是：当前类本身

方式三：Lock锁  --- JDK5.0新增  
1. 面试题：synchronized 与 Lock的异同？
   相同：二者都可以解决线程安全问题
   不同：synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器
        Lock需要手动的启动同步（lock()，同时结束同步也需要手动的实现（unlock()）
使用的优先顺序：
Lock ---> 同步代码块（已经进入了方法体，分配了相应资源 ) ---> 同步方法（在方法体之外)

```
### 9 sleep() 和 wait() 方法的区别？
```
相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。
不同点：
① 两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait()
② 调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中
③ 关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。
```
### 10 Java中多线程的创建有几种方式？
```
方式一：继承Thread类的方式
方式二：实现Runnable接口的方式
新增方式一：实现Callable接口。 --- JDK 5.0新增
如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？
1. call()可以返回值的。
2. call()可以抛出异常，被外面的操作捕获，获取异常的信息
3. Callable是支持泛型的
新增方式二：使用线程池
好处：
1.提高响应速度（减少了创建新线程的时间）
2.降低资源消耗（重复利用线程池中线程，不需要每次都创建）
3.便于线程管理
      corePoolSize：核心池的大小
      maximumPoolSize：最大线程数
      keepAliveTime：线程没任务时最多保持多长时间后会终止
```
### 11 String、StringBuffer、StringBuilder的区别?
```
String:不可变字符序列，底层使用char[]存储。
StringBuffer:可变的字符序列;线程安全，效率低;底层使用char[]存储。
StringBuilder:可变的字符序列;JDK5.0新增，线程不安全，效率高;底层使用char[]存储。
扩容问题:如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。
默认情况下，扩容为原来容量的2倍 + 2，同时将原数组中的元素复制到新的数组中。
```
### 12 ArrayList、LinkedList、Vector三者的异同点？

同: 三者都是实现了List接口，存储数据的特点的相同：存储有序的、可重复的数据<br>
不同:<br>
 ArrayList:是List的主要实现类，线程不安全、效率高；底层使用Object[] elementData存储.<br>
 源码分析(jdk1.8):ArrayList list = new ArrayList()初始化时(没有添加元素之前)底层是只是新建一个空的Object[]对象数组,当开始add数据的时候,则见一个长度为10的默认Object[]对象数组,用来保存数据,当添加到超过数据长度是,开始扩容, 默认情况是扩容为当前数组长度的1.5倍,同时将原来数组中的数据复制到当前数组.
 而(jdk1.7)在初始化时候就建立默认长度的Object[]对象数组,其他的过程和jdk1.8一样.<br>
 LinkedList: 对于频繁的插入和删除操作，使用此类效率比ArrayList高；底层使用双向列表存储.<br>
 源码分析(jdk1.8):LinkedList list = new LinkedList()初始化时,在内部声明了一个内部类Node节点,维护的是一个双链表结构,每一次add操作都是将该对象封装到Node节点中.<br>
 Vecetor:作为List接口的古老实现类；线程安全、效率低；底层使用Object[] elementData存储.<br>
 源码分析:jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组在扩容方面，默认扩容为原来的数组长度的2倍。
### 13 HashMap的底层实现原理？
```
从JDK 1.7开始说起:
HashMap map = new HashMap()开始在底层创建一个长度为16的Entry[] 数组.在此之前已经
put(key, value)多次,知道本次map.put(key1, value1),首先通过可以所在类的hashCode()计算器哈希值，
即该条数据在Entry[]数组中位置：
  如果该哈希值对应Entry[]数组的位置为空，则插入成功 --> 情况1
  如果该哈希值对应Entry[]数组的位置不为空(可能存在一条数据或者一个链表),开始对比
  (key1, value1)的哈希值与该位置上所有元素的哈希值:
      如果(key1, value1)与该位置上所有元素的哈希值均不相同，则插入成功 --> 情况2
      如果(key1, value1)与该位置上的某条数据(key2, value2)的哈希值相等，则开始比较key1.value.equals(key2.value):
          如果equals返回false，则添加成功 --> 情况3
          如果equals返回true,则用value2替换value1
说明: 情况2和情况3(key1, value1)都是采用链表方式存储.
补充JDK 1.8:
1.new HashMap()的时候不会一开始就创建一个长度为16的数组，只有在第一次put()操作后，才创建数组。
2.JDK 1.8底层使用的数组是Node[],而非Entry[]
3.JDK 1.7底层使用的是数组+链表, JDK 1.8使用的是数组+链表+红黑树
4.JDK 1.7的链表采用的是头插法，JDK 1.8的链表采用的是尾插法。
5.JDK 1.8中当链表长度大于8，并且Node[]数组长度大于64时，链表转换成红黑树。
在不断添加的过程中会涉及到扩容问题，当数组中位置使用超过临界值且下一个存储的位置不空的时候，
将数组长度扩容为原来的两倍，并且把原数组复制到新的数组中。
HashMap底层典型属性的属性的说明：
DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16
DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75
threshold：扩容的临界值，=容量*填充因子：16 * 0.75 => 12
TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树:8
MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量:64
```

### 14 谈一谈如何理解面向对象编程语言？
首先我们先说一下什么是类和对象，类就是对一个事物的描述，包括它固有的属性及其完成某个动作
所具备的行为，而对象它是类的实例，是对应实际存在该类事物的一个个体，我们在面向对象设计中
重点是对类的设计，而设计类重点是设计类的成员。
然后，在我们Java语言范畴类，我们将功能和结构都封装到类中，然后通过类的实例化即对象来调用
相关的功能结构。
    比如说我们在与控制台交互过程可以使用Sacnner进行输入，操作字符串时，我们可以使用String
    类，创建String对象。当我们要放访问计算机文件时，使用File类创建一个文件对象，通过输入
    输出流将文件读入到内存中。或者涉及到网络资源访问，我们可以使用URL类，创建该类的对象
    访问网络上的资源文件。
最后就是我们在前端和数据库交互过程中，我们向前端提供数据，可以通过json对象传递相关的值，或
者我们数据存入数据库中，也是将前端获取到的数据封装成一个对象，然后存入数据库时在将每个对象
的属性进行拆分将一条一条的数据存入数据库中中对应的字段，在这些过程中我们操作的基础都是一个
个对象。

### 15 抽象类和接口的异同点？
相同点：不能实例化；都可以包含抽象方法的。
不同点：
1) 把抽象类和接口(java7,java8,java9)的定义、内部结构解释说明
2) 类：单继承性    接口：多继承
   类与接口：多实现

###  HashMap和 Hashtable的异同点？

###  CurrentHashMap 与 Hashtable的异同？
