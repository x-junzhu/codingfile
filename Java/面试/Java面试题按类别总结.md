# Java面试题按类别总结(2020.10.07)
## 1、Java基础
 1.1 equals和==区别(null哪个能用), 如果没有重写equals方法,那么a==b和a.equals(b)一样吗(2020字节提前批)<br>

1.2 hashcode和equals(2020字节提前批)<br>

1.3 创建线程的方法及区别(2020字节提前批)<br>

1.4 try catch能捕获到哪些异常(2020字节提前批)<br>

1.5 重载和重写的区别(2020招银网络提前批)<br>
① 概念

重载:同一个类中,相同的方法名;不同的参数列表,包括不同的参数类型和不同的参数个数

重写:子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作.
重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。

② 重载和重写的规则

③ 重载: 不表现为多态性<br>
重写: 表现为多态性

重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。
所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；
而对于多态，只等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。

1.6 static和final会被重写吗(2020招银网络提前批)<br>
***final***
1. final 用来修饰一个类:此类不能被其他类所继承。比如：String类、System类、StringBuffer类<br>
2. final 用来修饰方法：表明此方法不可以被重写比如：Object类中getClass()<br>
3. final 用来修饰变量：此时的"变量"就称为是一个常量<br>
4. final修饰属性：可以考虑赋值的位置：显式初始化、代码块中初始化、构造器中初始化
5. final修饰局部变量：尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。       
> static final 用来修饰属性：全局常量<br>

***static***<br>
static修饰属性：静态变量（或类变量）
1. 属性，是否使用static修饰，又分为：静态属性  vs 非静态属性(实例变量)<br>
2. 实例变量：我们创建了类的多个对象，每个对象都独立的拥一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。<br>
静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。<br>
3. static修饰属性的其他说明：<br>
 ① 静态变量随着类的加载而加载。可以通过"类.静态变量"的方式进行调用<br>
 ② 静态变量的加载要早于对象的创建。<br>
 ③ 由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。<br>

|  |类变量|实例变量|
|:----:|:----:|:----:|
|类|yes|no|
|对象|yes|yes|
<br>

static修饰方法：静态方法、类方法<br>
1. 随着类的加载而加载，可以通过"类.静态方法"的方式进行调用

2.
|  |静态方法|非静态方法|
|:----:|:----:|:----:|
|类|yes|no|
|对象|yes|yes|

3. 静态方法中，只能调用静态的方法或属性非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性
4. 静态属性举例：System.out; Math.PI;

1.7 string三姐妹(2020招银网络提前批)<br>
String(JDK1.0)不可变的字符序列; 底层使用final char[]存储<br>
StringBuffer(JDK1.0)可变的字符序列;线程安全的, 效率低; 底层使用transient char[]存储<br>
StringBuilder(JDK1.5)可变的字符序列；jdk5.0新增的，线程不安全的，效率高；底层使用char[]存储<br>
***String:字符串, 使用一对""引起来表示***<br>
1.String声明为final的，不可被继承<br>
2.String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示String可以比较大小<br>
3.String内部定义了final char[] value用于存储字符串数据<br>
4.通过字面量的方式（区别于new给一个字符串赋值，此时的字符串值声明在字符串常量池中)<br>
5.字符串常量池中是不会存储相同内容(使用String类的equals()比较，返回true)的字符串的<br>

***不可变性的说明***<br>
1.当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。<br>
2.当对现的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。<br>
3.当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。<br>

关于可变性的扩容问题<br>
扩容问题:如果要添加的数据底层数组装不下了，那就需要扩容底层的数组。默认情况下，扩容为原来容量的2倍 + 2，同时将原数组中的元素复制到新的数组中。<br>


1.8 逻辑与的短路原则, &&如果前面为false，后面如果有空指针语句，会不会报异常(2020招银网络提前批)<br>

1.9 类的生命周期(2020招银网络提前批)<br>

1.10 说说你理解的反射，应用在哪(可以往Spring框架上说)(2020招银网络提前批)<br>

1.11 arraylist，linkedlist，hashset区别和使用场景，线程安全(2020京东提前批)<br>

1.12 new子类的时候，子类和父类静态代码块，构造器的执行顺序(2020京东提前批)<br>

1.13 runnable和callable区别(2020京东提前批)<br>

1.14 用过序列化和反序列化吗(2020京东提前批)<br>

1.15 内存泄露的场景(2020招行总行提前批)<br>

1.16 说一下hashmap实现, 线程安全的hashmap(2020新浪微博提前批)<br>


## 2、JVM
> 2.1 类加载过程和双亲委派机制(2020字节提前批)<br>

> 2.2 新生代和老年代都用什么算法(2020字节提前批)<br>

> 2.3 jvm内存模型;堆的划分,垃圾回收算法(2020字节提前批)<br>

> 2.4 锁升级有哪些变化(2020招银网络提前批)<br>

> 2.5 锁升级有哪些变化? 自动升级的条件是什么?还是会自璇多少次或者其等待线程超过多少就升级?(2020招银网络提前批)<br>

> 2.6 CAS怎么解决ABA问题(2020招银网络提前批)<br>

> 2.7 双亲委派模型好处(2020京东提前批)<br>

## 3、多线程与高并发
> 3.1 synchronized(作用在哪些位置)和lock的原理及区别(2020字节提前批)<br>

> 3.2 描述一下乐观锁和悲观锁及其原理;synchronized和lock是乐观还是悲观及ABA问题(2020字节提前批)<br>

> 3.3 进程线程协程区别和联系(2020招银网络提前批)<br>

> 3.4 线程池核心参数(2020招银网络提前批)<br>

> 3.5 ThreadLocal原理, 同时引出内存泄露(2020京东提前批)<br>

## 4、Spring框架
> 4.1 说说依赖注入和ioc(控制反转)(2020字节提前批)<br>

> 4.2 说说aop(应用场景和注解)(Aspect Oriented Programming)(2020字节提前批)<br>

> 4.3 说一下动态代理(jdk和cglib), 同时说一下静态代理和动态代理区别(2020字节提前批)

## 5、设计模式
> 5.1 单例模式(2020字节提前批)<br>

> 5.2 设计模式的七大原则(2020招银网络提前批)<br>

> 5.3 适配器模式(2020招银网络提前批)

## 6、计算机网络
> 6.1 http和https区别及https请求过程(2020字节提前批)<br>

> 6.2 说一下加密算法(2020字节提前批)<br>

> 6.2 dns解析过程(2020字节提前批)<br>

> 6.3 TCP和UDP区别, tcp拥塞控制(2020招银网络提前批)<br>

> 6.4 tcp三次握手四次挥手工作在哪一层(2020京东提前批)<br>

## 7、计算机操作系统(Linux)
> 7.1 页面置换算法(2020字节提前批)<br>

> 7.2 LRU缓存，让我设计LRU思路(2020字节提前批)

## 8、Mysql数据库(包括缓存技术Redis和MQ消息队列)
> 8.1 索引作用及索引的数据结构B和B+树(2020字节提前批)<br>

> 8.2 聚簇索引是什么; innodb是什么索引(2020字节提前批)<br>

> 8.3 MySQL有几种搜索引擎，区别(2020招银网络提前批)<br>

> 8.4 数据库查询比较慢, 怎么排查? (说了explain，sql语句优化，分库分表，用redis)(2020招银网络提前批)<br>

> 8.5 redis分布式锁(2020招银网络提前批)<br>

> 8.6 如何保证redis和数据库一致性?(答:延时双删)(2020京东提前批)<br>

> 8.7 解释一下幻读, 事务特性及隔离级别(2020京东提前批)<br>

> 8.8 mysql主从复制的同步方式有几种(2020招行总行提前批)<br>

> 8.9 char和varchar区别(2020招行总行提前批)<br>

> 8.10 Innodb引擎的特点(2020新浪微博提前批)<br>

## 9、手撕代码
> 9.1 生产者消费者模型(2020字节提前批)<br>

> 9.2 判断两个链表是否相交(2020字节提前批)<br>

> 9.3 判断一个链表是否有环，求出入环节点; 如果链表是有环的，那如何求两链表的相交节点<br>

> 9.4 链表反转(2020京东提前批)<br>

> 9.5 二分法找排序数组中绝对值最小的元素(2020京东提前批)<br>