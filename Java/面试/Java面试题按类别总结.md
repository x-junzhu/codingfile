# Java面试题按类别总结(2020.10.07)
## 1、Java基础
> 1.1 equals和==区别(null哪个能用), 如果没有重写equals方法,那么a==b和a.equals(b)一样吗(2020字节提前批)

equals(): 方法
1. 是一个方法，而非运算符
2. 只能适用于引用数据类型
3. Object类中equals()的定义：
    public boolean equals(Object obj) {
	        return (this == obj);
	  }
* 说明：Object类中定义的equals()和==的作用是相同的：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体

4. 像String、Date、File、包装类等都重写了Object类中的equals()方法。重写以后，比较的不是两个引用的地址是否相同，而是比较两个对象的"实体内容"是否相同。  
5. 通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的"实体内容"是否相同。那么，我们就需要对Object类中的equals()进行重写.重写的原则：比较两个对象的实体内容是否相同.

== ：运算符
1. 可以使用在基本数据类型变量和引用数据类型变量中
2. 如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（不一定类型要相同）
+ 如果比较的是引用数据类型变量：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体
+ 补充： == 符号使用时，必须保证符号左右两边的变量类型一致。

所以, ==可以判断对象为null, equals()不能, 如果该类没有重写equals方法, 则使用Object类的equals的方法, 而Object中的equals使用就是==判断

> 1.2 hashcode和equals(2020字节提前批)<br>

> 1.3 创建线程的方法及区别(2020字节提前批)

方式一：继承Thread类的方式

方式二：实现Runnable接口的方式

方式三：实现Callable接口。 --- JDK 5.0新增

如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？
1. call()可以返回值的。
2. call()可以抛出异常，被外面的操作捕获，获取异常的信息
3. Callable是支持泛型的

方式四：使用线程池

好处：
1.提高响应速度（减少了创建新线程的时间）
2.降低资源消耗（重复利用线程池中线程，不需要每次都创建）
3.便于线程管理
      corePoolSize：核心池的大小
      maximumPoolSize：最大线程数
      keepAliveTime：线程没任务时最多保持多长时间后会终止

> 1.4 try catch能捕获到哪些异常(2020字节提前批)

异常分类(广义的异常包括错误)
```
java.lang.Throwable
  |-----java.lang.Error:一般不编写针对性的代码进行处理。
  |-----java.lang.Exception:可以进行异常的处理
      |------编译时异常(checked)
        |-----IOException
        |-----FileNotFoundException
        |-----ClassNotFoundException
      |------运行时异常(unchecked,RuntimeException)
        |-----NullPointerException
        |-----ArrayIndexOutOfBoundsException
        |-----ClassCastException
        |-----NumberFormatException
        |-----InputMismatchException
        |-----ArithmeticException
```
try catch能捕获到java.lang.Exception

> 1.5 重载和重写的区别(2020招银网络提前批)

① 概念

重载:同一个类中,相同的方法名;不同的参数列表,包括不同的参数类型和不同的参数个数

重写:子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作.
重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。

② 重载和重写的规则

③ 重载: 不表现为多态性<br>
重写: 表现为多态性

重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。
所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；
而对于多态，只等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。

> 1.6 static和final会被重写吗(2020招银网络提前批)

static和final都不能被重写, 静态方法在编译期就被确定了, 所以不能被重写.

***final***
1. final 用来修饰一个类:此类不能被其他类所继承。比如：String类、System类、StringBuffer类<br>
2. final 用来修饰方法：表明此方法不可以被重写比如：Object类中getClass()<br>
3. final 用来修饰变量：此时的"变量"就称为是一个常量<br>
4. final修饰属性：可以考虑赋值的位置：显式初始化、代码块中初始化、构造器中初始化
5. final修饰局部变量：尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。       
> static final 用来修饰属性：全局常量<br>

***static***<br>
static修饰属性：静态变量（或类变量）
1. 属性，是否使用static修饰，又分为：静态属性  vs 非静态属性(实例变量)<br>
2. 实例变量：我们创建了类的多个对象，每个对象都独立的拥一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。<br>
静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。<br>
3. static修饰属性的其他说明：<br>
 ① 静态变量随着类的加载而加载。可以通过"类.静态变量"的方式进行调用<br>
 ② 静态变量的加载要早于对象的创建。<br>
 ③ 由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。<br>

|  |类变量|实例变量|
|:----:|:----:|:----:|
|类|yes|no|
|对象|yes|yes|
<br>

static修饰方法：静态方法、类方法<br>
1. 随着类的加载而加载，可以通过"类.静态方法"的方式进行调用

2.
|  |静态方法|非静态方法|
|:----:|:----:|:----:|
|类|yes|no|
|对象|yes|yes|

3. 静态方法中，只能调用静态的方法或属性非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性
4. 静态属性举例：System.out; Math.PI;

> 1.7 string三姐妹(2020招银网络提前批)

String(JDK1.0)不可变的字符序列; 底层使用final char[]存储<br>
StringBuffer(JDK1.0)可变的字符序列;线程安全的, 效率低; 底层使用transient char[]存储<br>
StringBuilder(JDK1.5)可变的字符序列；jdk5.0新增的，线程不安全的，效率高；底层使用char[]存储<br>
***String:字符串, 使用一对""引起来表示***<br>
1.String声明为final的，不可被继承<br>
2.String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示String可以比较大小<br>
3.String内部定义了final char[] value用于存储字符串数据<br>
4.通过字面量的方式（区别于new给一个字符串赋值，此时的字符串值声明在字符串常量池中)<br>
5.字符串常量池中是不会存储相同内容(使用String类的equals()比较，返回true)的字符串的<br>

***不可变性的说明***<br>
1.当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。<br>
2.当对现的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。<br>
3.当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。<br>

关于可变性的扩容问题<br>
扩容问题:如果要添加的数据底层数组装不下了，那就需要扩容底层的数组。默认情况下，扩容为原来容量的2倍 + 2，同时将原数组中的元素复制到新的数组中。<br>


> 1.8 逻辑与的短路原则, &&如果前面为false，后面如果有空指针语句，会不会报异常(2020招银网络提前批)

> 1.9 类的生命周期(2020招银网络提前批)

> 1.10 说说你理解的反射，应用在哪(可以往Spring框架上说)(2020招银网络提前批)>

> 1.11 arraylist，linkedlist，hashset区别和使用场景，线程安全(2020京东提前批)

ArrayList、LinkedList、Vector三者的异同点(后面再补充一下HashSet)

同: 三者都是实现了List接口，存储数据的特点的相同：存储有序的、可重复的数据<br>
不同:<br>
 ArrayList:是List的主要实现类，线程不安全、效率高；底层使用Object[] elementData存储.<br>
 源码分析(jdk1.8):ArrayList list = new ArrayList()初始化时(没有添加元素之前)底层是只是新建一个空的Object[]对象数组,当开始add数据的时候,则见一个长度为10的默认Object[]对象数组,用来保存数据,当添加到超过数据长度是,开始扩容, 默认情况是扩容为当前数组长度的1.5倍,同时将原来数组中的数据复制到当前数组.
 而(jdk1.7)在初始化时候就建立默认长度的Object[]对象数组,其他的过程和jdk1.8一样.

 LinkedList: 对于频繁的插入和删除操作，使用此类效率比ArrayList高；底层使用双向列表存储.<br>
 源码分析(jdk1.8):LinkedList list = new LinkedList()初始化时,在内部声明了一个内部类Node节点,维护的是一个双链表结构,每一次add操作都是将该对象封装到Node节点中.

 Vecetor:作为List接口的古老实现类；线程安全、效率低；底层使用Object[] elementData存储.<br>
 源码分析:jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组在扩容方面，默认扩容为原来的数组长度的2倍。

> 1.12 new子类的时候，子类和父类静态代码块，构造器的执行顺序(2020京东提前批)

> 1.13 runnable和callable区别(2020京东提前批)

> 1.14 用过序列化和反序列化吗(2020京东提前批)

> 1.15 内存泄露的场景(2020招行总行提前批)

> 1.16 说一下hashmap实现, 线程安全的hashmap(2020新浪微博提前批)<br>

```
从JDK 1.7开始说起:
HashMap map = new HashMap()开始在底层创建一个长度为16的Entry[] 数组.在此之前已经
put(key, value)多次,知道本次map.put(key1, value1),首先通过可以所在类的hashCode()计算器哈希值，
即该条数据在Entry[]数组中位置：
  如果该哈希值对应Entry[]数组的位置为空，则插入成功 --> 情况1
  如果该哈希值对应Entry[]数组的位置不为空(可能存在一条数据或者一个链表),开始对比
  (key1, value1)的哈希值与该位置上所有元素的哈希值:
      如果(key1, value1)与该位置上所有元素的哈希值均不相同，则插入成功 --> 情况2
      如果(key1, value1)与该位置上的某条数据(key2, value2)的哈希值相等，则开始比较key1.value.equals(key2.value):
          如果equals返回false，则添加成功 --> 情况3
          如果equals返回true,则用value2替换value1
说明: 情况2和情况3(key1, value1)都是采用链表方式存储.
补充JDK 1.8:
1.new HashMap()的时候不会一开始就创建一个长度为16的数组，只有在第一次put()操作后，才创建数组。
2.JDK 1.8底层使用的数组是Node[],而非Entry[]
3.JDK 1.7底层使用的是数组+链表, JDK 1.8使用的是数组+链表+红黑树
4.JDK 1.7的链表采用的是头插法，JDK 1.8的链表采用的是尾插法。
5.JDK 1.8中当链表长度大于8，并且Node[]数组长度大于64时，链表转换成红黑树。
在不断添加的过程中会涉及到扩容问题，当数组中位置使用超过临界值且下一个存储的位置不空的时候，
将数组长度扩容为原来的两倍，并且把原数组复制到新的数组中。
HashMap底层典型属性的属性的说明：
DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16
DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75
threshold：扩容的临界值，=容量*填充因子：16 * 0.75 => 12
TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树:8
MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量:64
```


## 2、JVM
> 2.1 类加载过程和双亲委派机制(2020字节提前批)<br>

类加载过程: 加载(loading)=>链接(验证->准备->解析)=>初始化

![avatar](image/classloader.png)

***加载阶段***
1. 通过一个类的全限定名获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

***链接阶段***
1. 验证
* 目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求, 保证被加载类的正确性, 不会危害虚拟机自身安全
* 主要包括四种验证: 文件格式验证, 元数据验证, 字节码验证, 符号引用验证
> 使用BinaryViewer查看字节码文件，其开头均为 CAFE BABE ，如果出现不合法的字节码文件，那么将会验证不通过

2. 准备
* 为类变量分配内存并且设置类变量的默认初始值, 即零值
* 这里不包含用final修饰的static, 因为final在编译的时候就会分配了, 准备阶段会显示初始化.
* 这里不会为实例变量分配初始化, 类变量会分配在方法区中, 而实例变量会随着对象一起分配到Java堆中。
3. 解析
* 将常量池内的符号引用转换为直接引用的过程.
* 事实上, 解析操作往往会伴随着JVM在执行完初始化之后再执行.
* 符号引用就是一组符号来描述所以引用的目标。符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移或一个间接定位到目标的句柄。
* 解析的主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等

***初始化阶段***

1. 初始化阶段就是执行类构造器方法\<clinit>()的过程
2. 此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。也就是说，当我们代码中包含**static变量或者静态代码块**的时候，就会有\<clinit>()方法
3. \<clinit>()方法中的指令按语句在源文件中出现的顺序执行
4. \<clinit>()不同于类的构造器(关联：构造器是虚拟机视角下的\<init>())
5. 若该类具有父类，JVM会保证子类的\<clinit>()执行前，父类的\<clinit>()已经执行完毕
6. 虚拟机必须保证一个类的\<clinit>()方法在多线程下被同步加锁,即：一个类只会被类的加载器加载一次

***双亲委派机制***

Java虚拟机对class文件采用的是按需加载的方式, 也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。

类加载器分类
1. 启动类加载器（引导类加载器，Bootstrap ClassLoader）
* 这个类加载使用C/C++语言实现的，嵌套在JVM内部。
* 它用来加载Java的核心库（JAVAHOME/jre/1ib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类。
* 并不继承自ava.lang.ClassLoader，没有父加载器。
* 加载扩展类和应用程序类加载器，并指定为他们的父类加载器。
* 出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类

2. 扩展类加载器（Extension ClassLoader）
* Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。
* 派生于ClassLoader类
* 父类加载器为启动类加载器
* 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/1ib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。

3. 应用程序类加载器（系统类加载器，AppClassLoader）
* java语言编写，由sun.misc.LaunchersAppClassLoader实现
* 派生于ClassLoader类
* 父类加载器为启动类加载器
* 它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库
* 该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载
* 通过classLoader#getSystemclassLoader()方法可以获取到该类加载器

![avatar](image/classloader_classifer.png)



工作原理:

* 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行;
* 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器;
* 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。

![avatar](image/loader.png)

**优点**
1. 避免类的重复加载
2. 保护程序安全，防止核心API被随意篡改
* 自定义类：java.lang.String
* 自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）

> 2.2 新生代和老年代都用什么算法(2020字节提前批)<br>

> 2.3 jvm内存模型;堆的划分,垃圾回收算法(2020字节提前批)

JVM内存模型:

![avatar](image/jvm_memory_model.png)

一个进程对应一个JVM实例, 对应一个RunTime实例

RunTime Data Area

堆:

![avatar](image/jvm_heap.png)

堆的划分: 年轻代和老年代, 在年轻代中又可以划分为Eden和Survivor0、Survivor1区

* Eden : Survivor0 : Survivor1 = 8 : 1 : 1
* Young Gen : Old Gen = 1 : 2

**堆内的垃圾回收**

我们创建的对象, 一般都是存放在Eden区的, 当我们Eden区满了后，就会触发Minor GC(Young GC)操作

![avatar](image/jvm_MinorGc01.png)

当我们进行一次垃圾收集后，红色的(没有指针指向的对象)将会被回收, 而绿色的还会被占用着, 将绿色存放到Survivor0(From)区。同时我们给每个对象设置了一个年龄计数器, 每一次回收后就是加1

同时Eden区继续存放对象, 当Eden区再次存满的时候, 又会触发一个Minor GC操作, 此时GC将会把 Eden和 Survivor0(From)中的对象 进行一次收集, 把存活的对象放到 Survivor1(To)区, 同时把Survivor0(From)中的对象拷贝到Survivor1(To)区并让其年龄加1

![avatar](image/jvm_MinorGc02.png)

我们继续不断的进行对象生成 和 垃圾回收, 当Survivor0/1中的对象的年龄达到15的时候, 将会触发一次 Promotion晋升的操作, 也就是将年轻代中的对象 晋升到 老年代中

![avatar](image/jvm_MinorGc03.png)

思考：幸存者区满了后?

* 特别注意，在Eden区满了的时候，才会触发MinorGC，而幸存者区满了后，不会触发MinorGC操作
* 如果Survivor区满了后，将会触发一些特殊的规则，也就是可能直接晋升老年代

***对象分配的特殊情况***

![avatar](image/jvm_object_asign.png)

方法区:

程序计数器: 记录下一个要执行的字节码指令

虚拟机栈:以栈帧的形式存在, 一个栈帧即程序中的一个方法, 每个栈帧主要包含4大块和一些附加信息

* 局部变量表: 存储方法中的形参和局部变量, 以Slot的形式存在, 包括8中基本数据类型和引用数据类型(类、接口、数组). 在非静态方法中, 局部变量表中索引0的位置存储的是this

* 操作数栈(表达式栈): 根据字节码指令弹出和压入操作数. 其中byte、short、char、boolean都是以int形式存储(4 byte)

* 动态链接: 指向运行时常量池的方法引用, 因为一个类运行过程中需要需多其他类, 所以JVM将所需要的的类加载的运行时常量池中, 每个方法通过一个指针指向该引用, 在需要使用的时候通过符号引用找到该类即可

* 方法返回地址: 存储调用该方法的程序计数器的值. 

本地方法栈：首先了解本地方法, 使用native(与abstract关键字不能同时使用)修饰调用C/C++语言的方法. 而本地方法栈就是管理本地方法的调用. 也允许实现固定或者动态可扩展其内存大小. 

> 2.4 锁升级有哪些变化(2020招银网络提前批)<br>

> 2.5 锁升级有哪些变化? 自动升级的条件是什么?还是会自璇多少次或者其等待线程超过多少就升级?(2020招银网络提前批)<br>

> 2.6 CAS怎么解决ABA问题(2020招银网络提前批)<br>

> 2.7 双亲委派模型好处(2020京东提前批)

**优点**
1. 避免类的重复加载
2. 保护程序安全，防止核心API被随意篡改
* 自定义类：java.lang.String
* 自定义类：java.lang.abc（报错：阻止创建 java.lang开头的类）

## 3、多线程与高并发
> 3.1 synchronized(作用在哪些位置)和lock的原理及区别(2020字节提前批)<br>

> 3.2 描述一下乐观锁和悲观锁及其原理;synchronized和lock是乐观还是悲观及ABA问题(2020字节提前批)<br>

> 3.3 进程线程协程区别和联系(2020招银网络提前批)<br>

> 3.4 线程池核心参数(2020招银网络提前批)<br>

> 3.5 ThreadLocal原理, 同时引出内存泄露(2020京东提前批)<br>

## 4、Spring框架
> 4.1 说说依赖注入和ioc(控制反转)(2020字节提前批)<br>

> 4.2 说说aop(应用场景和注解)(Aspect Oriented Programming)(2020字节提前批)<br>

> 4.3 说一下动态代理(jdk和cglib), 同时说一下静态代理和动态代理区别(2020字节提前批)

## 5、设计模式
> 5.1 单例模式(2020字节提前批)<br>

> 5.2 设计模式的七大原则(2020招银网络提前批)<br>

> 5.3 适配器模式(2020招银网络提前批)

## 6、计算机网络
> 6.1 http和https区别及https请求过程(2020字节提前批)<br>

> 6.2 说一下加密算法(2020字节提前批)<br>

> 6.2 dns解析过程(2020字节提前批)<br>

> 6.3 TCP和UDP区别, tcp拥塞控制(2020招银网络提前批)<br>

> 6.4 tcp三次握手四次挥手工作在哪一层(2020京东提前批)<br>

## 7、计算机操作系统(Linux)
> 7.1 页面置换算法(2020字节提前批)<br>

> 7.2 LRU缓存，让我设计LRU思路(2020字节提前批)

## 8、Mysql数据库(包括缓存技术Redis和MQ消息队列)
> 8.1 索引作用及索引的数据结构B和B+树(2020字节提前批)<br>

> 8.2 聚簇索引是什么; innodb是什么索引(2020字节提前批)<br>

> 8.3 MySQL有几种搜索引擎，区别(2020招银网络提前批)<br>

> 8.4 数据库查询比较慢, 怎么排查? (说了explain，sql语句优化，分库分表，用redis)(2020招银网络提前批)<br>

> 8.5 redis分布式锁(2020招银网络提前批)<br>

> 8.6 如何保证redis和数据库一致性?(答:延时双删)(2020京东提前批)<br>

> 8.7 解释一下幻读, 事务特性及隔离级别(2020京东提前批)<br>

> 8.8 mysql主从复制的同步方式有几种(2020招行总行提前批)<br>

> 8.9 char和varchar区别(2020招行总行提前批)<br>

> 8.10 Innodb引擎的特点(2020新浪微博提前批)<br>

## 9、手撕代码
> 9.1 生产者消费者模型(2020字节提前批)<br>

> 9.2 判断两个链表是否相交(2020字节提前批)<br>

> 9.3 判断一个链表是否有环，求出入环节点; 如果链表是有环的，那如何求两链表的相交节点<br>

> 9.4 链表反转(2020京东提前批)<br>

> 9.5 二分法找排序数组中绝对值最小的元素(2020京东提前批)<br>